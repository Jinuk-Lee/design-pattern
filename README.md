# design-pattern
디자인 패턴 세미나를 통해 공부한 내용을 업로드합니다. 

### __[챕터 내용]__<br>
Chapter1 : [디자인 패턴의 소개와 전략 패턴](https://jinuk.notion.site/Chapter1-424d081881524d1981055a924541f2ce)
- __필요한 기초 지식__
  - `추상화`,`캡슐화`,`다형성`,`상속`
- __객체지향 원칙__
  - 바뀌는 부분은 `캡슐화`
  - 상속보다는 `구성`을 활용
  - 구현보다는 `인터페이스에 맞춰 프로그래밍`
- **객체지향 패턴**
  - 전략 패턴
    - 전략 패턴은 알고리즘군을 정의하고 **캡슐화**해서 각각
    의 알고리즘군을 수정해서 쓸 수 있게 해 줍니다. 
    전략 패턴을 사용하면 클라이언트로부터 알고리즘을 분리해서 독립적으로 변경할 수 있습니다.
- __핵심 정리__
  - 훌륭한 객체지향 디자인을 위해서는 재사용성, 확장성, 관리의 용이성을 가져야함.
  - 패턴이 코드를 바로 제공하는 것은 아니고, __디자인 문제의 보편적인 해법을 제공합니다.__
  - 대부분의 패턴은 시스템의 일부분을 독립적으로 변경하는 방법을 제공합니다.
  - 패턴은 다른 개발자와의 의사소통을 극대화하는 역할을 합니다.


Chapter2 : [옵저버 패턴](https://jinuk.notion.site/Chapter2-bfc65c40d2b943d1a73c0a7c18351459)
- __객체지향 원칙__
  - 상호 작용하는 객체 사이에서는 가능하면 느슨한 결합을 사용해야한다.
    - `훨씬 더 유연하고 변화에 강한 디자인`
- **객체지향 패턴**
  - 옵저버 패턴
    - 일련의 객체 사이에서 **일대다 의존성을 정의**하며 한 객체의 상태가 바뀌면 **그 객체에 의존 하는 모든 객체들에게 연락이 갑니다.**
- __핵심정리__
  - 옵저버 패턴은 객체들 사이에 일대다 관계를 정의합니다.
  - 주제는 옵저버들이 `Observer` 인터페이스를 구현한다는 것을 제외하면 옵저버에 관해 
  전혀 모르기 때문에 이들은 `느슨한 결합`입니다.
  - 옵저버 패턴을 사용하면 `주제 → 옵저버(푸시 방식),주제←옵저버(풀 방식)`이 있습니다.
    - **일반적으로 풀 방식이 맞는 방식입니다.**

Chapter3 : [데코레이터 패턴](https://jinuk.notion.site/Chapter3-6a53a5c1544c4f95831a7e1b91fe1356)
- __객체지향 원칙__
  - `클래스는 확장에는 열려 있고, 변경에는 닫혀 있어야 한다.(OCP)`
- **객체지향 패턴**
  - 데코레이터 패턴
    - 객체에 추가 요소를 동적으로 더할 수 있으며, 서브클래스르 만들 때보다 훨씬 유연하게 기능을
      확장할 수 있습니다.
- **핵심정리**
  - 디자인의 유연성 면에서 보면 상속을 확장하는 일은 좋지 않습니다.
  - 데코레이터 클래스의 형식은 그 클래스가 감싸는 클래스 형식을 반영합니다.
  - **데코레이터는 자기가 감싸고 있는 구성 요소의 메소드를 호출한 결과에 새로운 기능을 더함으로써 행동을 확장합니다.**
  - 데코레이터 패턴을 사용하면 자잘한 객체가 많이 추가될 수 있고, 너무 많이 사용하면 코드가 필요 이상으로 복잡해집니다.